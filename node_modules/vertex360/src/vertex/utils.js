const superagent = require('superagent')
const path = require('path')
const fs = require('fs')
const TURBO_URL = 'https://turbo-dashboard.herokuapp.com'
const NODE_MODULES_PATH = (process.platform == 'win32') ? 'node_modules\\vertex360\\dist\\vertex' : 'node_modules/vertex360/dist/vertex'
let currentSite = null

// confirms that TURBO_APP_ID and TURBO_APP_SLUG are defined
const isValidApp = (env) => {
    if (env.TURBO_APP_ID == null)
        return 'TURBO_APP_ID'

    if (env.TURBO_APP_ID == '<TURBO_APP_ID>')
        return 'TURBO_APP_ID'

    if (env.TURBO_APP_ID.length < 20)
        return 'TURBO_APP_ID'
    
    if (env.TURBO_APP_SLUG == null)
        return 'TURBO_APP_SLUG'

    if (env.TURBO_APP_SLUG == '<TURBO_APP_SLUG>')
        return 'TURBO_APP_SLUG'

    if (env.TURBO_APP_SLUG.length < 6)
        return 'TURBO_APP_SLUG'

    if (env.TURBO_API_KEY == null)
        return 'TURBO_API_KEY'

    if (env.TURBO_API_KEY == '<TURBO_API_KEY>')
        return 'TURBO_API_KEY'

    if (env.TURBO_API_KEY.length < 20)
        return 'TURBO_API_KEY'

    return null
}

const getRequest = (url, params, headers) => {
  if (headers == null)
    headers = {'Accept':'application/json'}

  return new Promise((resolve, reject) => {
    superagent.get(url)
    .query(params)
    .set(headers)
    .end((err, response) => {
      if (err){
        reject(err)
        return
      }

      // const payload = response.body || response.text
      let payload = null
      if (headers.Accept == 'application/json')
        payload = response.body || response.text

      resolve(payload)
    })
  })
}

const postRequest = (endpoint, params, headers) => {
	if (headers == null)
    headers = {'Accept':'application/json'}

	return new Promise((resolve, reject) => {
		superagent.post(endpoint)
		.send(params)
		.set(headers)
		.end((err, response) => {
			if (err){
				reject(err)
				return
			}

			// const payload = res.body || res.text
      let payload = null
      if (headers.Accept == 'application/json')
        payload = response.body || response.text

			resolve(payload)
		})
	})
}

const fetchTextFile = (url) => {
  return new Promise((resolve, reject) => {
    superagent.get(url).query(null)
    .end((err, res) => {
      if (err){
        reject(err)
        return
      }

      resolve(res.text)
    })
  })
}

const resetPage = (pageName, appslug) => {
  return new Promise(function(resolve, reject){
    if (pageName==null){
      reject(new Error('Missing pageName argument'))
      return
    }

    if (appslug==null){
      reject(new Error('Missing appslug argument'))
      return
    }

    var filename = pageName+'.txt'
    var page_url = 'https://s3.amazonaws.com/turbo360-vertex/pages/'+appslug+'/'+filename

    fetchTextFile(page_url)
    .then(function(data) {
      fs.writeFileSync('/tmp/'+filename, data)
      var parsed = JSON.parse(data)
      resolve(parsed)
    })
    .catch(function(err) {
      reject(err)
    })
  })
}

const fetchSite = (siteId, useCache) => {
  if (useCache == null) // default to true for using cache
    useCache = true

  return new Promise((resolve, reject) => {
    if (currentSite!=null && useCache==true){ // defer to cached site:
      resolve(currentSite)
      return
    }

    const endpoint = TURBO_URL + '/api/site/' + siteId
    superagent.get(endpoint).query(null)
    .set('Accept', 'application/json')
    .end((err, response) => {
      if (err){
        reject(err)
        return
      }

      const body = response.body
      if (body.confirmation != 'success'){
        reject(new Error(body.message))
        return
      }

      currentSite = body.result
      resolve(currentSite)
    })
  })
}

const globalConfig = (env) => {
    return new Promise(function(resolve, reject){
        if (env.TURBO_ENV == 'dev'){ // local version, fetch file. no need to validate app credentials
            // TODO: another filepath for windows
            const filePath = path.join(__dirname, '/pages/global.json').replace(NODE_MODULES_PATH, '')

            fs.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err)
                    return
                }

                try {
                    resolve(JSON.parse(data))
                }
                catch(err){
                    reject(err)
                }
            })

            return
        }

        const missingKey = isValidApp(env)
        if (missingKey != null){
            reject(new Error('Please Set Your '+missingKey))
            return
        }

        fetchSite(env.TURBO_APP_ID, false) // fetch site first
        .then(site => {
            if (site.api.key != env.TURBO_API_KEY){
                reject(new Error('Unauthorized'))
                return
            }

            currentSite = site
            resolve(site.globalConfig)
        })
        .catch(err => {
            reject(err)
        })
    })
}

module.exports = {
  get: getRequest,
  post: postRequest,
  fetchTextFile: fetchTextFile,
  fetchSite: fetchSite,
  globalConfig: globalConfig,
  isValidApp: isValidApp,
  resetPage: resetPage,
  slugVersion: (text, numRandomChars) => {
  	let slug = text.toString().toLowerCase()
  			.replace(/\s+/g, '-')           // Replace spaces with -
  			.replace(/[^\w\-]+/g, '')       // Remove all non-word chars
  			.replace(/\-\-+/g, '-')         // Replace multiple - with single -
  			.replace(/^-+/, '')             // Trim - from start of text
  			.replace(/-+$/, '');            // Trim - from end of text

  	if (numRandomChars == null)
  		return slug.toLowerCase()

  	if (numRandomChars <= 0)
  		return slug.toLowerCase()

  	var randomString = ''
  	var possible = 'abcdefghijklmnopqrstuvwxyz0123456789'
  	for (var i=0; i <numRandomChars; i++)
  		randomString += possible.charAt(Math.floor(Math.random() * possible.length))

  	return slug.toLowerCase()+'-'+randomString
  },

  truncateText: (text, limit) => {
  	if (text.length < limit)
  		return text

  	return text.substring(0, limit)+'...'
  },

  // human readable date
  formattedDate: (date) => {
    const options = {weekday:'long', year:'numeric', month:'long', day:'numeric'}
    if (date == null)
      date = new Date()
    return date.toLocaleDateString('en-US', options) // Monday, May 6, 2019
  },

  scrapeInstagram: (username, captionLimit) => {
    if (captionLimit==null)
      captionLimit = 70

    return new Promise((resolve, reject) => {
      const igUrl = 'https://www.instagram.com/'+username+'/?__a=1'
      getRequest(igUrl)
      .then(instagram => {
        const recentIGPosts = []
        if (instagram == null){
          resolve(recentIGPosts)
          return
        }

        // validate the fuck out of this:
        if (instagram.graphql == null){
          resolve(recentIGPosts)
          return
        }

        // this crashed a lot when IG throttles an ip address:
        if (instagram.graphql.user == null){
          resolve(recentIGPosts)
          return
        }

        if (instagram.graphql.user.edge_owner_to_timeline_media == null){
          resolve(recentIGPosts)
          return
        }

        if (instagram.graphql.user.edge_owner_to_timeline_media.edges == null){
          resolve(recentIGPosts)
          return
        }

        // instagram feed:
        const feed = instagram.graphql.user.edge_owner_to_timeline_media.edges
        feed.forEach(postData => {
          if (postData.node != null){
            const post = {}
            post.shortcode = postData.node.shortcode
            post.image = postData.node.thumbnail_src
            post.caption = postData.node.edge_media_to_caption.edges[0].node.text
            post.caption = post.caption.substring(0, captionLimit)+'...'
            recentIGPosts.push(post)
          }
        })

        resolve(recentIGPosts)
      })
      .catch(err => {
        reject(err)
      })
    })
  },

  scrapePreview: (text, limit) => {
    return new Promise((resolve, reject) => {
      if (text==null || text==undefined){
        resolve(null)
        return
      }

      superagent.post('https://platform.turbo360-vector.com/scrapepreview')
      .send({text:text, limit:limit})
      .set('Accept', 'application/json')
      .end((err, response) => {
        if (err){
          reject(err)
          return
        }

        const payload = response.body
        resolve(payload)
      })
    })
  }

}

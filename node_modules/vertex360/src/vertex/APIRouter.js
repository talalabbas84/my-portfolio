const express = require('express')
const path = require('path')
const Router = require('./Router')
const utils = require('./utils')
const BASE_DIR = __dirname + '/../../../../'

class APIRouter {
  constructor(config){
    this.site_id = config.site_id
    this.api_key = config.api_key
    this.env = config.env || 'dev'
    this.tmp = config.tmp || '/tmp'

    this.turbo = require('turbo360')({site_id: config.site_id})
    this.checkCollectionDB = this.checkCollectionDB.bind(this)
    this.createRouter = this.createRouter.bind(this)
    this.populateRouter = this.populateRouter.bind(this)
    this.local = this.local.bind(this)
    this.prod = this.prod.bind(this)
  }

  checkCollectionDB(collectionName){
    const localDirectory = path.join(BASE_DIR, this.tmp)

    // const localDirectory = path.join(__dirname, this.tmp).replace(folder+'/', '')
  	const collectionFilePath = (this.env=='dev') ? localDirectory+'/'+collectionName+'.db' : this.tmp+'/'+collectionName+'.db'

    return new Promise((resolve, reject) => {
  		this.turbo.checkCollectionFile(collectionName, collectionFilePath)
  		.then(data => { // load collection file from backing store if necessary
  			return (data.found) ? null : this.turbo.loadCollection(collectionName, collectionFilePath, this.api_key)
  		})
  		.then(data => {
  			resolve(data)
  		})
  		.catch(err => {
  			reject(err)
  		})
  	})
  }

  createRouter(env){
    return (env=='dev') ? new express.Router() : new Router()
  }

  populateRouter(router, controllers, directory){
    router.get('/', (req, res) => { // returns list of resources
		const resources = []
		const keys = Object.keys(controllers)
		keys.forEach(key => {
			const controller = controllers[key]
			const ctr = new controller()
			resources.push({
				name: key,
				collectionName: ctr.collectionName(),
				schema: ctr.schema()
			})
		})

		res.json({
			confirmation: 'success',
			data: resources
		})
    })

	router.post('/', (req, res) => {
		const task = req.body.task
		if (task == null){
			res.json({confirmation:'fail', message:'Missing task parameter'})
			return
		}
		
		if (task == 'resetpage'){
			const pageName = req.body.page
			if (pageName == null){
				res.json({confirmation:'fail', message:'Missing page parameter'})
				return	
			}

			const appslug = req.body.appslug
			if (appslug == null){
				res.json({confirmation:'fail', message:'Missing appslug parameter'})
				return	
			}

			utils.resetPage(pageName, appslug)
			.then(data => {
				res.json({confirmation:'success', data:data})
			})
			.catch(err => {
				res.json({confirmation:'fail', message:err.message})
			})
			
			return
		}
		
		res.json({confirmation:'fail', message:'Invalid task: '+task})
	})


    router.get('/:resource', (req, res) => {
    	const controller = controllers[req.params.resource]
    	if (controller == null){
    		res.json({confirmation:'fail', message:'Invalid resource'})
    		return
    	}

      const ctr = new controller()
    	this.checkCollectionDB(ctr.collectionName())
    	.then(data => {
    		return ctr.get(req.query)
    	})
    	.then(data => {
    		res.json({confirmation:'success', data:data})
    	})
    	.catch(err => {
    		res.json({confirmation:'fail', message:err.message})
    	})
    })

    router.get('/:resource/:id', (req, res) => {
    	const controller = controllers[req.params.resource]
    	if (controller == null){
    		res.json({confirmation:'fail', message:'Invalid resource'})
    		return
    	}

      const ctr = new controller()
    	this.checkCollectionDB(ctr.collectionName())
    	.then(data => {
    		return ctr.getById(req.params.id)
    	})
    	.then(data => {
    		res.json({confirmation:'success', data:data})
    	})
    	.catch(err => {
    		res.json({confirmation:'fail', message:err.message})
    	})
    })

    router.post('/:resource', (req, res) => {
    	const controller = controllers[req.params.resource]
    	if (controller == null){
    		res.json({confirmation:'fail', message:'Invalid resource'})
    		return
    	}

      const ctr = new controller()
    	this.checkCollectionDB(ctr.collectionName())
    	.then(data => {
    		return ctr.post(req.body)
    	})
    	.then(data => {
    		res.json({confirmation:'success', data:data})
    	})
    	.catch(err => {
    		res.json({confirmation:'fail', message:err.message})
    	})
    })

    router.put('/:resource/:id', (req, res) => {
    	const controller = controllers[req.params.resource]
    	if (controller == null){
    		res.json({confirmation:'fail', message:'Invalid resource'})
    		return
    	}

      const ctr = new controller()
    	this.checkCollectionDB(ctr.collectionName())
    	.then(data => {
        const params = req.body
        delete params['timestamp'] // can never update this
    		return ctr.put(req.params.id, params)
    	})
    	.then(data => {
    		res.json({confirmation:'success', data:data})
    	})
    	.catch(err => {
    		res.json({confirmation:'fail', message:err.message})
    	})
    })

    router.delete('/:resource/:id', (req, res) => {
    	const controller = controllers[req.params.resource]
    	if (controller == null){
    		res.json({confirmation:'fail', message:'Invalid resource'})
    		return
    	}

      const ctr = new controller()
    	this.checkCollectionDB(ctr.collectionName())
    	.then(data => {
    		const id = req.params.id
    		return ctr.delete(id, null)
    	})
    	.then(() => {
    		res.json({confirmation:'success', data:{id:req.params.id}}) // return the ID so client side can track which entity removed
    	})
    	.catch(err => {
    		res.json({confirmation:'fail', message:err.message})
    	})
    })
  }

  local(controllers){ // this is a standard express router
    const router = this.createRouter('dev')
    this.populateRouter(router, controllers)
    return router
  }

  prod(controllers){
    const router = this.createRouter('prod')
    this.populateRouter(router, controllers)
    return router
  }

  router(controllers){
    const router = this.createRouter(this.env)
    this.populateRouter(router, controllers)
    return router
  }

}

module.exports = APIRouter
